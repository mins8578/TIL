### HTTP Header의 형식

```jsx
# HTTP Header 예시
# "이름: 값" 형식으로 작성
# 대소문자를 구분하지 않음 (Content-Type = content-type)

Content-Type: application/json      # 본문의 데이터 형식
Content-Length: 256                 # 본문의 크기 (바이트)
Authorization: Bearer abc123xyz     # 인증 정보
User-Agent: Mozilla/5.0             # 요청을 보낸 브라우저/앱 정보
```

<br>

### 요청(Request) Header

| Header 이름 | 역할 | 예시 | 비유 |
| --- | --- | --- | --- |
| `Host` | 요청을 받을 서버 주소 | `Host: [www.example.com](http://www.example.com/)` | 받는 사람 주소 |
| `User-Agent` | 요청을 보내는 클라이언트 정보 | `User-Agent: Chrome/120.0` | 보내는 사람 신분증 |
| `Accept` | 원하는 응답 데이터 형식 | `Accept: text/html` | "한글로 답장해 주세요" |
| `Authorization` | 인증 정보 (로그인 토큰 등) | `Authorization: Bearer token123` | 출입증, 신분증 |
| `Content-Type` | 보내는 데이터의 형식 | `Content-Type: application/json` | "이 편지는 한글로 썼어요" |

<br>

### 응답(Response) Header

| Header 이름 | 역할 | 예시 | 비유 |
| --- | --- | --- | --- |
| `Content-Type` | 응답 데이터의 형식 | `Content-Type: text/html` | "이 답장은 한글이에요" |
| `Content-Length` | 응답 데이터의 크기 | `Content-Length: 1024` | 편지지 몇 장인지 |
| `Set-Cookie` | 브라우저에 저장할 쿠키 | `Set-Cookie: session=abc123` | "다음에 올 때 이 쪽지 보여줘" |
| `Cache-Control` | 캐싱(저장) 정책 | `Cache-Control: max-age=3600` | "1시간 동안 보관해도 돼" |
| `Location` | 리다이렉트 주소 | `Location: /new-page` | "여기로 다시 와" |

<br>

### Body가 있는 경우 vs 없는 경우

| 상황 | Body 유무 | 예시 |
| --- | --- | --- |
| 단순 조회 요청 (GET) | ❌ 보통 없음 | 웹페이지 열기, 검색 |
| 데이터 전송 (POST) | ✅ 있음 | 로그인, 회원가입, 글쓰기 |
| 성공 응답 | ✅ 있음 | HTML 페이지, JSON 데이터 |
| 리다이렉트 응답 (3xx) | ❌ 보통 없음 | 다른 페이지로 이동 |
| 오류 응답 (4xx, 5xx) | ✅ 있을 수 있음 | 오류 메시지 |

<br>

### Body의 데이터 형식

Body에 담기는 데이터는 `Content-Type` Header로 형식을 명시한다.

| Content-Type | 설명 | 사용 예시 |
| --- | --- | --- |
| `text/html` | HTML 문서 | 웹페이지 |
| `text/plain` | 일반 텍스트 | 단순 문자열 |
| `application/json` | JSON 데이터 | API 통신 |
| `application/x-www-form-urlencoded` | 폼 데이터 | 로그인 폼 제출 |
| `multipart/form-data` | 파일 업로드 포함 폼 | 이미지 업로드 |

<br>

### PUT vs PATCH

**PATCH**는 리소스를 ‘부분적으로 수정’ 할 때 사용하는 메서드다. 흔히 비교되는 **PUT**이 리소스를 ‘통째로 갈아 끼우는’ 개념이라면, **PATCH**는 ‘필요한 부분만 고치는’ 개념이다.

**PATCH의 핵심 개념**

- 목적 : 리소스의 일부 필드만 업데이트
- **명등성(Idempotency): 멱등하지 않음.**

**[예시 상황]**

- **PUT 요청:** `{"name": "김영희"}`만 보내면, 나이가 누락되었으므로 서버는 `{"id": 1, "name": "김영희", "age": null}`로 데이터를 아예 새로 써버린다. (데이터 유실 위험)
- **PATCH 요청:** `{"name": "김영희"}`만 보내면, 서버는 이름만 바꾸고 나이는 그대로 둔다. 결과는 `{"id": 1, "name": "김영희", "age": 25}`가 된다.

<br>

**PATCH의 구체적인 용도**

- **개인정보 수정**: 비밀번호만 변경하거나, 프로필 사진만 변경할 떄
- **게시글 상태 변경**: 게시글의 내용은 그대로 두고 ‘공개 여부’나 ‘승인 상태’ 필드 하나만 `true/false` 로 바꿀 때
- **조회수 카운트**: `{"increment": 1}` 같은 데이터를 보내 서버 측에서 현재 조회수에 1을 더하게 하는 로직

<br>

## REST API URL 설계 원칙

### 1. 명사를 사용해라

URL은 **자원(Resource)**을 나타내므로 명사를 사용한다.

| ❌ 잘못된 예 | ✅ 올바른 예 |
| --- | --- |
| `/getUsers` | `/users` |
| `/createUser` | `/users` (POST 메서드 사용) |
| `/deleteUser/1` | `/users/1` (DELETE 메서드 사용) |

<br>

### 2. 복수형을 사용해라

자원은 일반적으로 **컬렉션(모음)**을 나타내므로 복수형을 사용한다.

<br>

### 3. 계층 구조를 표현하라

자원 간의 관계는 URL 경로로 표현한다.

```jsx
/users/jeff/orders						# jeff의 주문 목록
/users/jeff/orders/123				# jeff의 123번 주문
/users/jeff/orders/123/items	# jeff의 123번 주문에 포함된 상품들
```

<br>

### 4. 소문자와 하이픈을 사용하라

| 규칙 | ❌ 잘못된 예 | ✅ 올바른 예 |
| --- | --- | --- |
| 소문자 사용 | `/Users`, `/USERS` | `/users` |
| 하이픈(-) 사용 | `/user_orders`, `/userOrders` | `/user-orders` |

<br>

### 5. 파일 확장자를 포함하지 마라

응답 형식은 HTTP 헤더로 지정한다.

<br>

## JSON - 데이터를 저장하고 전송하기 위한 텍스트 기반의 데이터 형식

### **JSON의 기본 문법**

```json
// JSON의 기본 구조
// 중괄호 {} 안에 "키": 값 쌍을 작성합니다
// 키는 반드시 큰따옴표(")로 감싸야 합니다
// 여러 항목은 쉼표(,)로 구분합니다

{
  "name": "jeff",
  "age": 30,
  "isInstructor": true
}
```

<br>

### JSON에서 사용할 수 있는 데이터 타입

| 타입 | 설명 | 예시 |
| --- | --- | --- |
| **문자열 (String)** | 텍스트 데이터, 큰따옴표로 감싸야 함 | `"임태종"` |
| **숫자 (Number)** | 정수 또는 소수, 따옴표 없이 작성 | `25`, `3.14` |
| **불리언 (Boolean)** | 참/거짓 값 | `true`, `false` |
| **null** | 값이 없음을 표현 | `null` |
| **배열 (Array)** | 여러 값의 순서 있는 목록 | `[1, 2, 3]` |
| **객체 (Object)** | 키-값 쌍의 집합 | `{"a": 1}` |

<br>

### 중첩 구조(Nested Structure)

```json
// 객체 안에 또 다른 객체나 배열을 포함할 수 있습니다
// 이를 통해 복잡한 데이터 구조를 표현합니다

{
  "instructor": {
    "name": "jeff",
    "koreanName": "임태종",
    "subjects": ["Python", "Git", "AWS"]
  },
  "studentCount": 25,
  "isActive": true
}
```

<br>

### 파이썬에서의 JSON 모듈

`import json`

**핵심 함수 4가지**

| 함수 | 방향 | 입력 | 출력 | 용도 |
| --- | --- | --- | --- | --- |
| `json.dumps()` | 직렬화 | Python 객체 | JSON 문자열 | 네트워크 전송, 로그 출력 |
| `json.dump()` | 직렬화 | Python 객체 | 파일에 저장 | 데이터 영구 저장 |
| `json.loads()` | 역직렬화 | JSON 문자열 | Python 객체 | API 응답 처리 |
| `json.load()` | 역직렬화 | 파일 | Python 객체 | 저장된 데이터 불러오기 |

<br>

---
<br>

**AccessToken을 Body로 받아 메모리에 저장하는 이유**

AccessToken은 수명이 짧고, 모든 API 요청마다 헤더에 실어 보내야 한다.

- **XSS(Cross-Site Scripting)방어**: AccessToken을 브라우저의 localStorage나 Cookie에 저장하면 JavaScript 코드로 접근이 가능해진다. 만약 해커가 악성 스크립트를 심으면 토큰을 바로 탈취 당할 수도 있다.
- **메모리(Variable) 저장**: 보통 응답 바디로 받아 프론트엔드의 변수(State)에 저장한다. 브라우저를 새로고침하면 사라지지만 그만큼 탈취가 어렵다.

<br>

**RefreshToken을 쿠키(HttpOnly)에 저장하는 이유**

RefreshToken은 수명이 길고 오직 AccessToken이 만료되었을 때 새로 발급받는 용도로만 쓰인다.

- **HttpOnly 옵션**: 쿠키를 설정할 때 `HttpOnly` 옵션을 주면 JavaScript가 이 쿠키를 읽을 수 없다.
- **CSRF(Cross-Site Request Forgery) 대응**: 쿠키는 CSRF 공격에 취약할 수 있지만, RefreshToken은 단순히 토큰 재발급 API에서만 사용되므로 서버에서 추가적인 검증을 통해 방어하기 수월하다.
- **자동 로그인 효과**: 새로고침을 해서 AccessToken이 사라져도 브라우저에 남아있는 RefreshToken 쿠키가 자동으로 서버에 전달되어 사용자는 다시 로그인할 필요 없이 새 AccessToken을 받을 수 있다.

<br>

**AccessToken을 서버(Redis)에 저장하지 않는 이유**

JWT 방식의 AccessToken은 Stateless(상태 없음)를 지향한다, 이는 한번 발급되면 그 뒤로 토큰의 상태에 대해 관리할 수 없으며 회원이 토큰을 통해 요청을 보낸 건지, 해커가 탈취해서 요청을 보낸 건지 알 수 없다.

- **자체 검증**: 토큰 안에 사용자의 정보와 유효기간이 이미 들어 있고, 서버가 가진 비밀키로 서명되어 있다.
- **서버 부하 감소**: 서버는 DB나 Redis를 조회할 필요 없이, 들어온 토큰이 유효한지만 수학적으로 계산하면 된다.

<br>

**RefreshToken을 Redis에 저장하는 이유**

RefreshToken은 **보안**상의 이유로 서버가 통제권을 쥐어야 한다.

- **토큰 탈취 대비 (강제 로그아웃)**: 만약 사용자가 핸드폰을 분실했다면 서버는 Redis에 저장된 RefreshToken을 삭제해버림으로써 해커가 더 이상 AccessToken을 재발급받지 못하게 차단할 수 있다.
