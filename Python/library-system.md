# [TIL] 도서관 시스템 구현으로 배우는 Python 예외 처리와 OOP

# 1. Python CLI 도서관 관리 시스템 구현 
> 기능 요구사항을 보며 도서관 관리 시스템 구현 중 마주한 문제들과 새롭게 알게된 내용

### CSV 도서 데이터 출력 문제
>내가 원했던 내용은 CSV 파일로부터 도서 데이터가 넘어왔을 때 제목, 저자, isbn 데이터가 모두 출력이 되길 바랬는데,
>
>'도서 등록 완료: title' 만 출력 되었다.
<img width="992" height="302" alt="Image" src="https://github.com/user-attachments/assets/adcd12e9-3373-49ba-96e8-04d6d41e8f75" />
<img width="1042" height="160" alt="Image" src="https://github.com/user-attachments/assets/5c286730-477c-4da3-a4e4-859e1b4f179c" />
<img width="1110" height="514" alt="Image" src="https://github.com/user-attachments/assets/cb341045-0121-40db-93c1-48a38aabd597" />

- 원인 : 이미지와 같이 lib.add_book() 으로 해놔서 add_book 메서드 안에 있는 print가 출력 되었다. 2번 도서 목록 조회를 눌러 보았을 때는 데이터가 모두 잘 넘어오는 것을 확인했다.

<img width="1042" height="270" alt="Image" src="https://github.com/user-attachments/assets/23c9d41c-2375-4a97-b1f7-27a5fbba3f98" />
- 해결 과정 : 이미지와 같이 new_book을 Book의 인스턴스로 하여금 생성한 뒤 도서를 추가하였을 때, Book 클래스에 있는 __str__ 함수가 자동으로 할당되어 출력 되었습니다.
<img width="1160" height="676" alt="Image" src="https://github.com/user-attachments/assets/54db2356-f202-4331-9a79-4dc4707fd931" />



### 회원 등록
> 회원 등록 시 처음에 이름 전화번호 입력을 받는데 그 회원이 책을 빌렸는지 여부에 대한 리스트도 클래스 내부에 만들어야 하는지에 대한 의견이 나왔습니다.

- 제 생각
> 회원 등록 시에는 처음이기에 당연히 빌린 책이 없을거라고 가정, 따라서 add_member 함수 파라미터에는 이름과, 전화번호만 두고 내부 함수에 책을 빌렸는지에 대한 여부 변수를 빈 리스트로 정의해 주었습니다.

---

### 예외 처리
> input 값을 입력해야 하는 부분이 많았는데 간과한 사실이 하나 있었다. 바로 "공백"이었다.
>
> 많은 입력값들을 모두 공백을 제거하기에는 하나하나 다 strip()을 사용해야 하기에 번거로움이 있었다.
>
> 스스로 생각해본 결과 get_input()이라는 함수를 만들어 이 함수 안에 .strip()을 내장시켜 input() 대신 get_input()을 사용하여 번거로움을 줄였다.
<img width="503" height="126" alt="Image" src="https://github.com/user-attachments/assets/e688b442-4ad2-4aa6-ac75-c4cbd6db06f2" />


 
##  도서관 시스템 구현에 사용된 Python 내장 예외문

데이터가 서비스에서 허용하는 형식에 맞는지, 논리적으로 타당한지 확인하는 과정에서 다음과 같은 예외들을 사용합니다.

| 예외 이름 | 의미 | 도서관 상황 예시 |
| :--- | :--- | :--- |
| **ValueError** | 타입은 맞으나 **내용물(값)**이 적절하지 않음 | 이름 입력 시 공백 입력, 나이 입력 시 5살 미만 입력 등 |
| **KeyError** | Dictionary 상자 안에서 특정 **이름표(Key)**를 찾지 못함 | `self.members` 사전에서 등록되지 않은 이름을 찾으려 할 때 |
| **FileNotFoundError** | 지정한 경로에 **파일이 존재하지 않음** | `books.csv` 파일을 읽으려는데 파일이 삭제되었거나 이름이 틀렸을 때 |
| **LookupError** | 무언가를 **찾으려고(Lookup) 시도**했으나 실패함 | ISBN 번호로 검색했는데 일치하는 도서가 단 한 권도 없을 때 |
| **RuntimeError** | 문법과 값은 맞으나 **현재 프로그램 상태**와 맞지 않음 | 책은 존재하지만 이미 대출된 상태라 대출이 불가능할 때 |
| **Exception** | 모든 에러를 아우르는 **조상님** | 예상치 못한 모든 상황을 대비한 최후의 그물 |

---

# 2. 객체 지향 프로그래밍 (OOP)
프로그램을 데이터와 행위를 하나의 집합으로 모아 관리하는 방식입니다.

### 🔹 객체 (Object / Instance)
* 서로 연관된 데이터와 그 데이터를 조작하기 위한 함수를 하나의 집합에 모아놓은 것입니다.
* 집합의 원소가 되는 변수나 함수는 **멤버(Member)** 또는 **속성(Attribute)**이라고 합니다.
* 객체의 속성인 함수는 **메서드(Method)**라고 부릅니다.

### 🔹 클래스 (Class)
```python
class Rectangle(object):
		def __init__(self, h, v):
				self.h = h
				self.v = v
				
		def area(self):
				return self.h * self.v
```     
* 객체를 만들기 위한 설계도입니다. 클래스를 만든 후 이를 이용하여 객체를 생성합니다.
* 예: `Rectangle`은 클래스이고, `r = Rectangle(10, 20)`으로 만들어진 `r`은 객체입니다.
> r = Rectangle(10, 20)
>
> a = r.area()
>
> print(a)
>
> #결과: 200

### 🔹 생성자 (Constructor)
```python
class 클래스이름(object):
		def __init__(self, 속성값1, 속성값2, 속성값3):
				self.속성이름1 = 속성값1
				self.속성이름2 = 속성값2
				self.속성이름3 = 속성값3
```
* `__init__` 함수를 말하며 클래스 정의에서 가장 중요한 함수입니다.
* 클래스 이름을 호출하여 객체를 생성할 때 실제로는 이 생성자 함수가 호출되어 속성값을 저장합니다.

### 🔹 상속 (Inheritance)
* 부모 클래스(Super class)의 내용을 자식 클래스(Child class)가 물려받는 것입니다.
* 부모의 속성과 메서드를 그대로 사용할 수 있어 코드 재사용성이 높아집니다.

---

## 3. 매직 메소드 (Magic Method)
파이썬의 매직 메소드는 클래스 내에서 특정 기능을 수행하기 위해 미리 정의된 메소드를 말한다.

메소드 중 __ 로 시작해서 로 끝나는 메소드들이 있는데 예시로 **__init**__ **__str**__ **__contains**__ 등과 같은 형태로 나타난다.

이러한 매직 메소드들은 파이썬의 다양한 내장 함수나 연산자가 해당 객체와 상호 작용할 때 호출되며, 이를 통해 객체의 동작을 유연하게 커스터마이징할 수 있게 된다.

예컨대 ‘in’ 연산자는 내부적으로 **__contains**__ 매직 메소드를 찾고 호출한다.

### ‘in’ 연산자와 List 자료형

파이썬에서 ‘a in b’ 구문이 수행될 때, 내부적으로 가장 먼저 b.**__contains**__(a)가 구현되어 있는지를 확인한다.

- 만약 **__contains**__ 메서드가 정의되어 있다면, 그 메소드를 바로 호출하여 그 결과(True/False)에 따라 ‘in’ 연산의 결과가 결정된다.
- **__contains**__ 가 없을 경우, 파이썬은 b가 이터러블(iterable)인지 확인한 뒤, for 루프를 돌며 하나씩 a == 요소를 비교해 가며 포함 여부를 판별한다.

## 즉, ‘in’ 연산자는 내부적으로 __**contains**__ 에 우선순위를 두고 동작하며, 만약 구현이 없다면 반복(iteration)을 통해 동작한다.
---

## 4. 이터레이터(Iterator)와 제너레이터(Generator)
반복 가능한 객체를 어떻게 효율적으로 만드는가에 대한 개념입니다.

### 🔹 이터레이터 (Iterator)
* `__iter__`와 `__next__` 매직 메소드를 구현한 객체입니다. 데이터를 하나씩 꺼내오는 '포인터' 역할을 합니다.

### 🔹 제너레이터 (Generator): 지연 평가(Lazy Evaluation)
* `yield` 키워드를 사용하여 이터레이터를 쉽게 만드는 특별한 함수입니다.
* **핵심 원리:** 데이터를 미리 다 만들어 메모리에 쌓지 않고, 필요한 시점(`next()` 호출 시점)에만 하나씩 생성합니다.
* **yield의 역할:** `return`과 달리 함수의 상태를 **'일시 정지'** 시킨 채 값을 반환하며, 다시 호출하면 멈춘 지점부터 다시 실행됩니다.

### 🔹 10억 개의 데이터 처리: List vs Generator
* **리스트 (List):** 10억 개의 데이터를 담을 메모리 공간이 통째로 필요합니다. 메모리 부족(Out of Memory)으로 프로그램이 종료될 위험이 큽니다.
* **제너레이터 (Generator):** 10억 번을 돌더라도 메모리에는 **지금 당장 꺼낸 숫자 1개**만 올라갑니다. 메모리 용량과 상관없이 실행이 가능합니다.

> **Q: 인덱싱이 되는 리스트가 더 좋은 것 아닌가?**
> 메모리에 올릴 수만 있다면 리스트가 빠르고 편리합니다. 하지만 현실적인 **메모리(RAM)라는 그릇의 크기** 때문에 대용량 데이터에서는 제너레이터를 쓸 수밖에 없는 상황이 생깁니다.


### yield란 무엇일까? - 제너레이터와의 관계

yield는 Pyton의 함수에서 데이터를 반환하고 함수의 상태를 유지하는 키워드이다. yield를 만나면 함수는 그 시점에서 잠시 멈추고, 그 값을 반환한 후 필요할 때 다시 실행한다.
