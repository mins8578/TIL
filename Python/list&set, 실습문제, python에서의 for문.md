## 리스트(List)와 세트(Set)의 차이

| 특징 | 리스트 (List) | 세트 (Set) |
| :--- | :--- | :--- |
| **기호** | 대괄호 `[ ]` | 중괄호 `{ }` |
| **순서 (Order)** | 있음 (넣은 순서대로 저장) | 없음 (무작위로 저장) |
| **중복 (Duplicate)** | 허용 (같은 값 여러 번 가능) | 불가 (중복된 값은 자동 제거) |
| **수정 가능 여부** | 가능 (Mutable) | 가능 (Mutable) |
| **인덱싱 (Index)** | 가능 (`list[0]`) | 불가능 (순서가 없어서 번호도 없음) |

<br>

### 주요 차이점 상세 설명
- List : 같은 데이터를 여러 번 담을 수 있다. ex) 쇼핑 리스트에 '사과'를 세 번 적는 것과 같다.
- Set : 중복을 절대 허용하지 않는다. 집합 개념이므로 똑같은 값을 넣어도 결과적으로는 하나만 남는다.

### 데이터 찾는 속도(성능)
- List : 특정 값이 있는지 찾으려면 처음부터 끝까지 훑어야 할 수도 있다. (데이터가 많을 수록 느려짐)
- Set : **라는 기술을 사용하기 때문에 데이터가 아무리 많아도 값이 있는지 없는지 빠르게 찾아낸다.

<br>

```python
# 1. 리스트: 중복 허용, 순서 유지
my_list = [1, 2, 2, 3, 1]
print(my_list) 
# 결과: [1, 2, 2, 3, 1] (그대로 출력)

# 2. 세트: 중복 자동 제거, 순서 무작위
my_set = {1, 2, 2, 3, 1}
print(my_set)
# 결과: {1, 2, 3} (중복은 사라지고 유일한 값만 남음)

# 3. 리스트에서 중복 제거할 때 꿀팁
raw_data = ["A", "B", "A", "C"]
unique_data = list(set(raw_data)) # 세트로 바꿨다가 다시 리스트로!
print(unique_data) # ['A', 'B', 'C']
```

<br>

### 언제 어떤 걸 써야 할까?
- List를 쓰는 경우 :
  - 데이터의 순서가 중요할 때 (예: 달리기 순위, 게시글 시간순)
  - 똑같은 데이터가 여러 번 나와야 할 때
  - 인덱스 번호로 꺼내야 할 때
- Set를 쓰는 경우 :
  - 데이터의 중복을 없애야 할 때:
  - 특정 값이 들어있는지 아주 빠르게 확인해야 할 때
  - 교집합, 합집합 등 수학적 집합 연산이 필요할 때

<br>
<br>

 
| 자료형 | 자주 쓰는 기능 |
| --- | --- |
| 문자열 | `split()`, `strip()`, f-string |
| 리스트 | `append()`, `pop()`, `len()` |
| 튜플 | 언패킹 (`x, y = point`) |
| 세트 | `&` 교집합, `|` 합집합, `-` 차집합 |
| 딕셔너리 | `get()`, `items()`, `keys()` |   

---

## 실습 문제

### 구구단 프로그램
```python
dan = int(input("단을 입력하세요: "))

# 유효성 검사
if dan < 0 or dan > 9:
    print("1부터 9단까지만 가능합니다.")
else:
    print(f"===={dan}단====")
    for i in range(1, 10):
        result = dan * i
        print(f"{dan} x {i} = {result}")
```
**결과**
```
단을 입력하세요: 4
====4단====
4 x 1 = 4
4 x 2 = 8
4 x 3 = 12
4 x 4 = 16
4 x 5 = 20
4 x 6 = 24
4 x 7 = 28
4 x 8 = 32
4 x 9 = 36
```

### 소수 찾는 알고리즘
```python
for nums in range(2, 101):
    is_decimal = True

    for divior in range(2, nums):
        if nums % divior == 0:
            is_decimal = False
            break

    if is_decimal:
        print(nums, end=' ')

print()
```
**결과**
```
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 
```

### 숫자 맞추기 게임
```python
import random

answer = random.randint(1, 100)

count = 0
while True:
    num = int(input("숫자를 입력하세요: "))
    count += 1
    if num > answer:
        print("더 작은 정수를 입력하세요.")
    elif num < answer:
        print("더 큰 정수를 입력하세요.")
    else:
        print(f"정답입니다! {count}번 만에 맞추셨습니다.")
        break
```

**결과**
```
숫자를 입력하세요: 1
더 큰 정수를 입력하세요.
숫자를 입력하세요: 90
더 작은 정수를 입력하세요.
숫자를 입력하세요: 50
더 작은 정수를 입력하세요.
숫자를 입력하세요: 40
더 작은 정수를 입력하세요.
숫자를 입력하세요: 30
더 작은 정수를 입력하세요.
숫자를 입력하세요: 20
더 작은 정수를 입력하세요.
숫자를 입력하세요: 10
더 작은 정수를 입력하세요.
숫자를 입력하세요: 9
더 작은 정수를 입력하세요.
숫자를 입력하세요: 5
더 작은 정수를 입력하세요.
숫자를 입력하세요: 3
정답입니다! 10번 만에 맞추셨습니다.
```
---
## 🫣 내가 느낀 `for`

- Python `for`는 단순 반복이 아님
- `for` 뒤에 오는 인자가 **그 객체의 역할을 그대로 가져오는 느낌**
- 마치 **상속받아서 바로 쓰는 것 같음**
- 단순히 `길이만큼 반복` 개념이 아님

<br>

## 🤔 정리하면

> Python의 for문은 “반복 횟수”가 아니라
“객체가 제공하는 반복 규칙(iteration protocol)”을 그대로 사용한다.
> 

즉,

- Java: **for가 주인**
- Python: **객체가 주인**

<br>

## **Java for문 사고 방식 (카운트 중심)**

- 반복 주체: `i`
- 컬렉션은 **보조 수단**
- “몇 번 반복할지”가 중심

👉 for문이 **반복을 지배함**

## Python for문 사고 방식 (객체 중심)

이때 핵심은 💥

- `for`는 **아무 것도 모름**
- 오직 이것만 함:

> “야 iterable,
> 
> 
> 👉 다음 값 하나씩 줘”
> 

<br>

### 📈 Python for 내부 실제 동작

```python
iterator = iter(iterable)
while True:
    try:
        x = next(iterator)
    except StopIteration:
        break
```

<br>

👉 **for문이 하는 일은 단 3가지**

1. `iter()` 호출
2. `next()` 호출
3. StopIteration 처리

🚨 **반복 규칙은 전부 iterable 객체가 결정**

<br>

# 👀 for는 그냥 **중계자**

### 다듬은 표현 (개념 정확)

> Python의 for문은 반복 횟수를 제어하는 구조가 아니라, 
`in` 뒤에 오는 객체가 제공하는 반복 규칙을 그대로 위임받아 실행하는 구조이다.
> 
> 
> 따라서 for문은 객체의 역할을 “복사”하는 것이 아니라, 
> 객체가 정의한 iteration 동작을 그대로 사용한다.
> 
> Java의 for문은 인덱스를 중심으로 동작하지만, 
> Python의 for문은 객체 중심(iterable 중심)으로 동작한다.
> 

 ✅ **가장 정확한 개념은 *위임(delegation)* + *iteration protocol*** 이다.

<br>

## range() vs 일반 객체 (List, Set 등)

`range()` 역시 함수가 아니라 숫자 생성 규칙을 가진 '객체'로 취급된다.

<br>

### 🔹 Case A: 일반 객체 (이미 존재하는 데이터)

```python
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)
```

- **특징**: 리스트라는 바구니에 담긴 물리적인 데이터를 순서대로 꺼내온다.

### 🔹 Case B: range() 객체 (규칙 기반 데이터)

```python
for i in range(5):
    print(i)
```

- **특징**: `range(5)`라는 객체는 숫자를 미리 다 만들어 두지 않는다.
- 대신 **"0부터 5 전까지 1씩 더한다"**는 공식만 가지고 있다가, `for`가 요청할 때마다 그 자리에서 숫자를 계산해서 던져준다. (**Lazy Evaluation**).

<br>

### Lazy Evaluation(지연 평가)이란?

> 말 그대로 "값이 실제로 필요할 때까지 계산을 뒤로 미루는 방식"을 의미한다.
>
